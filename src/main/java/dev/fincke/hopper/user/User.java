package dev.fincke.hopper.user;

import jakarta.persistence.*;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;
import org.hibernate.annotations.UuidGenerator;

import java.time.LocalDateTime;
import java.util.HashSet;
import java.util.Objects;
import java.util.Set;
import java.util.UUID;

// Entity mapped to "users" table with username and email indexes for fast lookups
@Entity
@Table(
    name = "users",
    indexes = {
        @Index(name = "idx_users_username", columnList = "username"),
        @Index(name = "idx_users_email", columnList = "email")
    }
)
public class User
{
    // * Attributes

    // UUID primary key (auto-generated by Hibernate)
    @Id
    @GeneratedValue
    @UuidGenerator
    private UUID id;

    // Username for authentication (required, unique, 3-50 characters)
    @NotBlank
    @Size(min = 3, max = 50)
    @Column(name = "username", nullable = false, unique = true, length = 50)
    private String username;

    // Email address (required, unique, validated format)
    @NotBlank
    @Email
    @Column(name = "email", nullable = false, unique = true)
    private String email;

    // BCrypt-encoded password (required, 60 characters for BCrypt hash)
    @NotBlank
    @Column(name = "password", nullable = false, length = 60)
    private String password;

    // Account enabled status (defaults to true)
    @Column(name = "enabled", nullable = false)
    private boolean enabled = true;

    // Account locked status (defaults to false)
    @Column(name = "account_locked", nullable = false)
    private boolean accountLocked = false;

    // Failed login attempts counter for account locking
    @Column(name = "failed_login_attempts", nullable = false)
    private int failedLoginAttempts = 0;

    // Account creation timestamp (auto-populated)
    @CreationTimestamp
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    // Last update timestamp (auto-updated)
    @UpdateTimestamp
    @Column(name = "updated_at", nullable = false)
    private LocalDateTime updatedAt;

    // Many-to-many relationship with roles (eager loading for security checks)
    @ManyToMany(fetch = FetchType.EAGER)
    @JoinTable(
        name = "user_roles",
        joinColumns = @JoinColumn(name = "user_id"),
        inverseJoinColumns = @JoinColumn(name = "role_id")
    )
    private Set<Role> roles = new HashSet<>();

    // * Constructors
    
    // Default constructor required by JPA
    protected User() {}

    // Main constructor for creating new users (password will be encoded separately)
    public User(String username, String email, String password)
    {
        this.username = Objects.requireNonNull(username, "username").trim();
        this.email = Objects.requireNonNull(email, "email").trim().toLowerCase();
        this.password = Objects.requireNonNull(password, "password");
    }

    // * Getters and Setters
    
    // User ID
    public UUID getId()
    {
        return id;
    }

    // User ID (primarily used by JPA)
    public void setId(UUID id)
    {
        this.id = id;
    }

    // Username
    public String getUsername()
    {
        return username;
    }

    // Username (trims whitespace on set)
    public void setUsername(String username)
    {
        this.username = username == null ? null : username.trim();
    }

    // Email
    public String getEmail()
    {
        return email;
    }

    // Email (normalized to lowercase on set)
    public void setEmail(String email)
    {
        this.email = email == null ? null : email.trim().toLowerCase();
    }

    // Password (BCrypt-encoded)
    public String getPassword()
    {
        return password;
    }

    // Password (should be BCrypt-encoded before setting)
    public void setPassword(String password)
    {
        this.password = password;
    }

    // Account enabled status
    public boolean isEnabled()
    {
        return enabled;
    }

    // Account enabled status
    public void setEnabled(boolean enabled)
    {
        this.enabled = enabled;
    }

    // Account locked status
    public boolean isAccountLocked()
    {
        return accountLocked;
    }

    // Account locked status
    public void setAccountLocked(boolean accountLocked)
    {
        this.accountLocked = accountLocked;
    }

    // Failed login attempts
    public int getFailedLoginAttempts()
    {
        return failedLoginAttempts;
    }

    // Failed login attempts
    public void setFailedLoginAttempts(int failedLoginAttempts)
    {
        this.failedLoginAttempts = failedLoginAttempts;
    }

    // Creation timestamp
    public LocalDateTime getCreatedAt()
    {
        return createdAt;
    }

    // Update timestamp
    public LocalDateTime getUpdatedAt()
    {
        return updatedAt;
    }

    // User roles
    public Set<Role> getRoles()
    {
        return new HashSet<>(roles);
    }

    // User roles (creates defensive copy on set)
    public void setRoles(Set<Role> roles)
    {
        this.roles = roles == null ? new HashSet<>() : new HashSet<>(roles);
    }

    // * Role Management Methods

    // Add a role to this user
    public void addRole(Role role)
    {
        if (role != null)
        {
            this.roles.add(role);
        }
    }

    // Remove a role from this user
    public void removeRole(Role role)
    {
        this.roles.remove(role);
    }

    // Check if user has a specific role
    public boolean hasRole(RoleType roleType)
    {
        return roles.stream()
            .anyMatch(role -> role.getName() == roleType);
    }

    // Check if user has admin privileges
    public boolean isAdmin()
    {
        return hasRole(RoleType.ADMIN);
    }

    // * Account Management Methods

    // Lock the account and reset failed attempts
    public void lockAccount()
    {
        this.accountLocked = true;
        this.failedLoginAttempts = 0;
    }

    // Unlock the account and reset failed attempts
    public void unlockAccount()
    {
        this.accountLocked = false;
        this.failedLoginAttempts = 0;
    }

    // Increment failed login attempts
    public void incrementFailedLoginAttempts()
    {
        this.failedLoginAttempts++;
    }

    // Reset failed login attempts (successful login)
    public void resetFailedLoginAttempts()
    {
        this.failedLoginAttempts = 0;
    }

    // * Overrides
    
    @Override
    public boolean equals(Object o)
    {
        if (this == o) return true;
        if (!(o instanceof User other)) return false;
        // Two users are equal if they have the same ID (ID-based equality for JPA entities)
        return id != null && id.equals(other.id);
    }

    @Override
    public int hashCode()
    {
        // Use ID for hash code, or 0 if not persisted yet
        return id != null ? id.hashCode() : 0;
    }

    @Override
    public String toString()
    {
        return "User{" +
                "id=" + id +
                ", username='" + username + '\'' +
                ", email='" + email + '\'' +
                ", enabled=" + enabled +
                ", accountLocked=" + accountLocked +
                ", failedLoginAttempts=" + failedLoginAttempts +
                ", roles=" + roles.size() + " roles" +
                '}';
    }
}